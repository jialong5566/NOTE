※权限修饰符
public     唯一类(类名与文件名一致)
protected
默认不写    类
private
---------------------------------------------
                权限范围  同包的定义(package后 内容一样)
public          本类      同包  				子类   	         	   当前工程内
protected       本类      同包  				子类在本身子类范围内
默认不写        本类      同包
private         本类



※特征修饰符
--------------------------------------------------------------------------------
final   变量  若没有初值，给一次赋值机会，变量在栈内存中，相当于常量
	      引用类型地址不变。
	      若是方法中的参数，则不可在方法体中改变，实际调用方法传参数时候相当于赋值
	属性  堆内存空间有默认值，必须经过程序赋值。
	方法  方法不能Override
	类    不能被extends
----------------------------------------------------------------------------
static	在静态元素区里面，
	类加载过程中只加载一次，
	属于类自己，静态之间互访，非静态访问静态，静态不能访问非静态，
	不能出现this、super
	类与对象共享，
	通过类直接访问，
	常驻内存中。
	属性	方法	块	内部类
--------------------------------------------------------------------------
类的加载机制
1.加载父类
2.父类产生自己静态空间， 摆放 属性 方法 块 执行块
	执行输出静态块中的代码
3.加载子类。。产生自己的静态空间，摆放 属性 方法 块 执行块。。
4.开辟对象空间
5.加载父类非静态成员  属性 方法 块 构造方法 执行块，执行构造方法

6.加载子类非静态成员 执行块，执行构造方法
7.交出地址
----------------------------------
abstract 修饰类和方法
抽象方法没有方法体  abstract void method();
抽象方法不能放在具体类里面 可以放在抽象类和接口里面

抽象类  允许含有抽象方法，如果都是抽象方法，就是接口
	属性 public static  final
	方法 public abstract
	不能有块，块为｛｝
	构造方法 不需要构建对象

	只能通过子类继承进行创建对象，父类的抽象方法不健全
类的关系
抽象类  继承  抽象类
抽象类  继承  具体类
具体类  继承  抽象类
具体类需要将父类方法具体化，或者自己也是抽象类
-------------------------------------------------
接口  interface  只定义规则，只能implement ，子类多实现
	接口(全抽象)中不能继承具体类
	抽象类可以直接多实现接口，
	具体类必须变为抽象类后，才能多实现接口

-------------------------------
native
调用其他语言
-----------------------------
transient synchronized volatile





单例模式
不能随便new  构造方法变为private
只能在本类中创建
块没有返回值，属性会随着构造方法产生栈溢出
保证安全 只此一份
private static className propName = new className()|null;
public static className getPropName(){ if(propName == null){ propName = new className(); };return propName }

饿汉式 服务器承载压力大，不会产生空指针。
懒汉式 可能产生空指针，不会浪费空间。
生命周期托管式


适配器模式
抽象类代替接口，不需要的方法具体化，并在执行时候抛出异常，让子类必须重写。

